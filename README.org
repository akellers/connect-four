#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:nil
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:nil todo:t |:t
#+TITLE: Vier Gewinnt
#+DATE: <2023-02-21 Di>
#+AUTHOR: Andreas Kellers
#+EMAIL: andreas.kellers@gmail.com
#+LANGUAGE: de
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.3 (Org mode 9.1.9)

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize, frame=single, rulecolor=\color{gray}}
#+LATEX_HEADER_EXTRA: \usepackage{ngerman, a4, longtable}
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE: Eine programmatische Annäherung
#+LATEX_COMPILER: pdflatex
#+DATE: \today

* Einführung

  *Connect four* (oder im Deutschen *Vier Gewinnt* ist ein
  Strategiespiel für zwei Spieler. Das Spielfeld besteht aus einem
  Gitter mit 7 Spalten (senkrecht) und 6 Reihen (waagerecht). Das
  Spielfeld steht aufrecht. Das Setzen der Steine kann nur in der
  nächsten freien Reihe erfolgen. Die Spieler setzen abwechselnd
  jeweils einen Spielstein (in klassisch in den Farben /Rot/ und
  /Gelb/). Ziel ist es, eine Reihe von 4 Steinen in der eigenen Farbe
  zu setzen. Dies kann senkrecht, waagerecht oder auch diagonal
  erfolgen.

  Es besteht jeweils abwechselnd Zugzwang. Die Steine können beliebig
  in eine der Spalten platziert werden (sofern noch nicht bis zur
  obersten, sechsten Reihe besetzt). Jeder Spiele hat genau $21 = 6
  \times 7 / 2$ Steine. Den ersten Zug hat Spieler Rot.

  Gewonnen hat der Spieler, dem es zuerst gelingt, eine Viererreihe zu
  bilden, d.h. vier Steine in vertikal, horizontal oder auch diagonal
  benachbarten Feldern.

* Kodierung

  Der Verlauf eines Spieles lässt sich eindeutig durch die Folge der
  Spalten beschreiben, in denen ein Spieler seinen Stein platziert.

  Ist zum Beispiel für die ersten $2 \times 3 = 6$ Züge die Folge der
  verwendeten Spalten $\{3, 2, 2, 1, 3, 4\}$ ergibt sich folgende
  Spielfeld mit $R = Rot$ für den ersten Spieler, $G = Gelb$ für den
  Zweiten. Zur Veranschaulichung in der tabellarischen Darstellung
  wird die Nummer des Spielzugs als Index an $R$ oder $G$ angezeigt.

  #+ATTR_LATEX: :environment longtable :align |c|c|c|c|c|c|c|
  |   1 | 2   | 3   |   4 | 5 | 6 | 7 |
  |-----+-----+-----+-----+---+---+---|
  |     |     |     |     |   |   |   |
  |     |     |     |     |   |   |   |
  |     |     |     |     |   |   |   |
  |     | R_3 | R_5 |     |   |   |   |
  | G_4 | G_2 | R_1 | G_6 |   |   |   |

  Die Kodierung als Liste $L = \{l_1, \ldots, \l_n\}$ mit $l_i \in \{1,
  \ldots 7\}$ erlaubt folgende Ableitungen:

  1. Spieler im $i$-ten Zug ist /Rot/, falls $i$ ungerade, sonst
     /Gelb/ (unter der Voraussetzung, dass /Rot/ den ersten Zug macht.
  2. Mit Zug $l_i$ befinden sich $i$ Spielsteine in dem Gitter.
  3. Die Liste hat eine maximale Länge $n = 6 \times 7 = 42$.
  4. In jede Spalte kann höchstens 6 mal ein Stein gesetzt werden,
     d.h.: Für $s = \{1, \dots, 7\}$ gibt es maximal 6 Indizes $i_j$
     mit $l_i_j = s$.
  5. Farbe und Position des Steins im Zug $l_i$ auf dem Gitter sind:
     + Farbe: /Rot/ falls $i \equiv 1 \mod 2$, sonst /Gelb/.
     + Spalte: $i$
     + Zeile: Es sei $L' = \{l_1, \ldots, l_i\}$ die Teilliste von
       $L$ bis zum Zug $l_i$. Die Zeile ist dann die Anzahl der
       Elemente $l_j$ in $L'$ mit $l_i = l_j$.



* Implementierung
  :PROPERTIES:
  :header-args:python:   :results output :python python -i 'src/connect-four.py' :exports both
  :END:

  Die Implementierung in =Python= erfolgt in dem Skript
  [[file:src/connect-four.py]]. Nachfolgende Beispiele verwenden das
  Skript und zeigen den jeweiligen Output.

  Für die Kodierung der Spielverläufe als Liste von Spaltenindizes
  wird in der Umsetzung ein String (Datentyp =str=) verwendet. Aus der
  oben verwendeten Liste wird in =Python= somit die Zeichenkette
  ='322134'=.

** Funktion =get_grid=

   Die Funktion =get_grid(s)= erzeugt aus einer derartigen Spielfolge
   eine Zeichenkette mit einer einfachen Darstellung des
   resultierenden Spielfelds.

   #+NAME: get_grid
   #+BEGIN_SRC python :var s = "322134"
    PLAYERS = { 0: 'R', 1: 'G' } # to suppress ASCII encoding
    print("Board for game sequence '%s':" % s)
    print(get_grid(s))
   #+END_SRC

   #+RESULTS: get_grid
   : 322134
   :  |                     | 6
   :  |                     | 5
   :  |                     | 4
   :  |                     | 3
   :  |    R  R             | 2
   :  | G  G  R  G          | 1
   :  +-1--2--3--4--5--6--7-+

** Funktion =decode=

   Die Funktion =get_grid(s)= nutzt intern ein Dictionary (Typ
   =dict=). Schlüssel für dieses Dictionary sind dabei die (besetzten)
   Positionen. Die Werte (Values) sind dabei die Spieler-Indizes. Die
   Positionen sind Tupel vom Typ =(int, int)=, Spieler sind =0= oder
   =1=. Hierbei ist zu beachten, dass die Werte für Zeilen und Spalten
   0-basiert sind, d.h. auf dem klassischen Spielfeld mit 6 Zeilen und
   7 Spalten git es Positionen von =(0, 0)= bis =(5, 6)=.

   In =Python= sieht das Dictionary für das oben gezeigte Gitter wie
   folgt aus:

   #+NAME: decode
   #+BEGIN_SRC python :var s = "322134"
    print("Dictionary for game sequence '%s':" % s)
    print(decode(s))
   #+END_SRC

   #+RESULTS: decode
   : Dictionary for game sequence 322134:
   : {(0, 1): 1, (1, 2): 0, (0, 0): 1, (1, 1): 0, (0, 3): 1, (0, 2): 0}
